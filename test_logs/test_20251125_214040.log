2025-11-25 21:40:41,153 [INFO] Test: tests/test_ai_api.py::test_ai_api_basic - PASSED
2025-11-25 21:40:41,155 [INFO] Test: tests/test_ai_api.py::test_ai_api_recognize_recharge - PASSED
2025-11-25 21:40:41,157 [INFO] Test: tests/test_ai_api.py::test_ai_api_recognize_help - PASSED
2025-11-25 21:40:41,158 [INFO] Test: tests/test_ai_api.py::test_ai_api_unknown_intent - PASSED
2025-11-25 21:40:41,160 [INFO] Test: tests/test_function_interface.py::test_get_user_input - PASSED
2025-11-25 21:40:41,163 [INFO] Test: tests/test_function_interface.py::test_login_success - PASSED
2025-11-25 21:40:41,166 [INFO] Test: tests/test_function_interface.py::test_login_failure - PASSED
2025-11-25 21:40:41,169 [INFO] Test: tests/test_function_interface.py::test_register_success - PASSED
2025-11-25 21:40:41,171 [INFO] Test: tests/test_function_interface.py::test_recharge - PASSED
2025-11-25 21:40:41,173 [INFO] Test: tests/test_interpreter.py::test_set_statement - PASSED
2025-11-25 21:40:41,175 [INFO] Test: tests/test_interpreter.py::test_do_statement_speak - PASSED
2025-11-25 21:40:41,176 [INFO] Test: tests/test_interpreter.py::test_do_statement_if - PASSED
2025-11-25 21:40:41,178 [INFO] Test: tests/test_interpreter.py::test_jump_statement - PASSED
2025-11-25 21:40:41,180 [INFO] Test: tests/test_lexer.py::test_lexer_keywords - PASSED
2025-11-25 21:40:41,181 [INFO] Test: tests/test_lexer.py::test_lexer_operators - PASSED
2025-11-25 21:40:41,182 [INFO] Test: tests/test_lexer.py::test_lexer_variables - PASSED
2025-11-25 21:40:41,184 [INFO] Test: tests/test_lexer.py::test_lexer_strings_numbers - PASSED
2025-11-25 21:40:41,185 [INFO] Test: tests/test_parser.py::test_parse_simple_script - PASSED
2025-11-25 21:40:41,186 [INFO] Test: tests/test_parser.py::test_parse_if_statement - PASSED
2025-11-25 21:40:41,187 [INFO] Test: tests/test_parser.py::test_parse_set_statement - PASSED
2025-11-25 21:40:41,188 [INFO] Test: tests/test_script_processing.py::test_get_script - PASSED
2025-11-25 21:40:41,189 [INFO] Test: tests/test_script_processing.py::test_get_script_en - PASSED
2025-11-25 21:40:41,190 [INFO] Test: tests/test_script_processing.py::test_get_tree - PASSED
2025-11-25 21:40:41,190 [INFO] Test: tests/test_script_processing.py::test_jump_to - PASSED
2025-11-25 21:40:41,311 [INFO] Test: tests/test_stress.py::test_concurrent_login - FAILED
2025-11-25 21:40:41,311 [ERROR] Test failed: tests/test_stress.py::test_concurrent_login
2025-11-25 21:40:41,312 [ERROR] Error details:
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000028DE79DB350>

    def test_concurrent_login(monkeypatch):
        """测试并发登录功能（前置注册测试用户）"""
        user_count = 50
        concurrent_users = 20
        test_users = generate_test_users(user_count)
    
        # 模拟数据库连接
        mock_cursor = MagicMock()
        mock_connection = MagicMock()
        mock_connection.cursor.return_value = mock_cursor
    
        # 前置步骤：注册所有测试用户（仅作为数据准备，不测试注册逻辑）
        with patch('backend.function_interface.mysql.connector.connect', return_value=mock_connection):
            # 注册时模拟用户不存在
            mock_cursor.fetchone.side_effect = [None] * user_count  # 所有用户初始不存在
            for username, password in test_users:
                Register(username, password, password)  # 调用注册函数创建用户
    
        # 登录测试：模拟数据库查询成功
        def mock_login_fetchone(username, password):
            for user, pwd in test_users:
                if user == username and pwd == password:
                    return {'username': username, 'password': password}
            return None
    
        # 重置cursor行为，用于登录测试
        mock_cursor.fetchone.side_effect = lambda *args: mock_login_fetchone(args[0][0], args[0][1])
    
        with patch('backend.function_interface.mysql.connector.connect', return_value=mock_connection):
            start_time = time.time()
    
            # 使用线程池模拟并发登录
            with ThreadPoolExecutor(max_workers=concurrent_users) as executor:
                futures = []
                for username, password in test_users:
                    futures.append(executor.submit(Login, username, password))
    
                success_count = 0
                for future in as_completed(futures):
                    if future.result():
                        success_count += 1
    
            end_time = time.time()
            duration = end_time - start_time
    
            print(f"\n并发登录测试:")
            print(f"总用户数: {user_count}")
            print(f"并发数: {concurrent_users}")
            print(f"成功数: {success_count}")
            print(f"成功率: {success_count/user_count*100:.2f}%")
            print(f"总耗时: {duration:.2f}秒")
            print(f"平均耗时: {duration/user_count:.4f}秒")
    
>           assert success_count == user_count
E           assert 0 == 50

tests\test_stress.py:86: AssertionError
2025-11-25 21:40:41,335 [INFO] Test: tests/test_stress.py::test_recharge_stress - FAILED
2025-11-25 21:40:41,336 [ERROR] Test failed: tests/test_stress.py::test_recharge_stress
2025-11-25 21:40:41,336 [ERROR] Error details:
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000028DE79C6F30>

    def test_recharge_stress(monkeypatch):
        """测试充值功能压力（限制金额为两位小数）"""
        test_user = "stress_test_user"
        test_password = "test_pass"
    
        # 生成100个随机金额，限制为两位小数
        recharge_amounts = [round(random.uniform(10, 1000), 2) for _ in range(100)]
        concurrent_recharges = 10
    
        # 模拟用户存在且初始余额为0
        mock_cursor = MagicMock()
        mock_cursor.fetchone.side_effect = [
            {'username': test_user, 'password': test_password},  # 登录查询
            {'username': test_user, 'remain': 0.0}  # 充值查询
        ]
    
        mock_connection = MagicMock()
        mock_connection.cursor.return_value = mock_cursor
    
        with patch('backend.function_interface.mysql.connector.connect', return_value=mock_connection):
            # 先登录
            Login(test_user, test_password)
            assert isLogin()
    
            start_time = time.time()
    
            # 并发充值
            with ThreadPoolExecutor(max_workers=concurrent_recharges) as executor:
                futures = [
                    executor.submit(Recharge, test_user, amount)
                    for amount in recharge_amounts
                ]
    
                success_count = 0
                for future in as_completed(futures):
                    if future.result():
                        success_count += 1
    
            end_time = time.time()
            duration = end_time - start_time
    
            print(f"\n充值压力测试:")
            print(f"总充值次数: {len(recharge_amounts)}")
            print(f"并发数: {concurrent_recharges}")
            print(f"成功数: {success_count}")
            print(f"成功率: {success_count/len(recharge_amounts)*100:.2f}%")
            print(f"总耗时: {duration:.2f}秒")
    
            # 验证所有金额都是两位小数
            for amount in recharge_amounts:
                assert isinstance(amount, float)
                assert len(str(amount).split('.')[1]) <= 2, f"金额 {amount} 小数位超过两位"
    
>           assert success_count == len(recharge_amounts)
E           assert 1 == 100
E            +  where 100 = len([143.37, 357.76, 247.6, 672.83, 543.27, 36.4, ...])

tests\test_stress.py:141: AssertionError
2025-11-25 21:40:41,341 [INFO] Test: tests/test_stress.py::test_script_execution_stress - PASSED
